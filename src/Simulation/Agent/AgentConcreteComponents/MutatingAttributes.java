package Simulation.Agent.AgentConcreteComponents;

import Simulation.Agent.AgentBaseComponents.BaseAttributes;
import Simulation.Agent.AgentInterfaces.Attributes;
import Simulation.Agent.AgentStructs.ColorModel;

import javax.print.DocFlavor;
import java.awt.*;
import java.io.Serializable;
import java.util.Random;

/** Makes up the agents attributes. Attributes are set values that don't change during the agent's life, except if
 * the agent mutates. Attributes define the agents qualities and behavior as well as their color and name.
 * @author Sam Burchmore
 * @version 1.0a
 * @since 1.0a
 */
public class MutatingAttributes extends BaseAttributes {

    /**
     * Constructs a BasicAttributes object using the input parameters.
     * <p>
     * The constructor simply takes the input parameters and assigns them
     * to the new BasicAttributes instance. Then it calls the calculateAttributes()
     * method to calculate the rest of the attributes. If the attributes mutationMagnitude
     * is greater than zero, it will generate its mutating color from its seed color.
     * @param spawningWeight the weight used for this agent when populating the environment
     * @param name the string that identifies the agent in the diagnostics view
     * @param ID the agents unique identifier, an agent will breed with and not eat agents with the same code
     * @param seedColor the agents initial color
     * @param mutationChance the percentage value for how likely the attributes are to mutate
     * @param range how far the agent can see and move in one turn
     * @param size used to calculate all the agents calculated stats
     * @param creationSize how many adjacent squares the agent will try to have children in, also used to calculate the creation cost.
     */
    public MutatingAttributes(int spawningWeight, String name, int ID, Color seedColor, ColorModel colorModel, int randomColorModelMagnitude, int mutationChance, int range, int size, int creationSize) {
        super(spawningWeight, name, ID, seedColor, colorModel, randomColorModelMagnitude, mutationChance, range, size, creationSize);
        mutateAttributesColor(
                getSize() / 100.0,
                getCreationSize() / 8.0,
                getRange() / 5.0,
                125);
    }

    public MutatingAttributes(Attributes attributesA, Attributes attributesB) {
        super(attributesA, attributesB);
        mutate();
        calculateAttributes();
    }

    @Override
    public Attributes combine(Attributes attributesB) {
        return new MutatingAttributes(this, attributesB);
    }

    /**
     * Mutates the input attributes object.
     * <p>
     * Has an 80% chance of mutating size, and a 10% chance for range or creationSize. If the diagnostics verbosity is
     * set to high, then a message with the agents name, mutated attribute and how much it mutated by is added to the log queue.
     */
    private void mutate() {
        if (getRandom().nextInt(100) < getMutationChance()) {
            int ran = getRandom().nextInt(10);
            int oldSize = getSize();
            int oldCreationSize = getCreationSize();
            int oldRange = getRange();
            if (ran < 8) {
                // Mutate size
                setSize(Math.min(Math.max(getSize() + 1, 2), 10));
            } else if (ran < 9) {
                // Mutate range
                setRange(Math.min(Math.max(getRange() + 1, 0), 5));
            } else {
                // Mutate creationAmount
                setCreationSize(Math.min(Math.max(getCreationSize() + 1, 1), 8));
            }
            if (getColorModel().equals(ColorModel.ATTRIBUTES)) {
                mutateAttributesColor(
                        (getSize() / 100.0) - (oldSize / 100.0),
                        (getCreationSize() / 8.0) - (oldCreationSize / 8.0),
                        (getRange() / 5.0) - (oldRange / 5.0),
                        125);
            }
        }
    }

    /**
     * Recalculates the mutating color.
     * <p>
     * When an agent mutates, its new color is generated by adding the constant multiplied
     * with the percentage difference, of one of its 3 mutating stats to a corresponding
     * chanel of the seed color. The mutating attributes correspond with the following RGB
     * channels: size-red, creationSize-green, range-blue. The result of the addition is
     * wrapped around (0-255)
     * @param a the percent change of the size attribute
     * @param b the percent change of the creationSize attribute
     * @param c the percent change of the range attribute
     */
    @Override
    public void mutateAttributesColor(double a, double b, double c, int constant) {
        int x2 = overflow255(getSeedColor().getRed(), ((int) (a * constant)));
        int y2 = overflow255(getSeedColor().getGreen(), ((int) (b * constant)));
        int z2 = overflow255(getSeedColor().getBlue(), ((int) (c * constant)));
        setMutatingColor(new Color(x2, y2, z2));
    }

    /**
     * Returns one of the agents 2 colors.
     * <p>
     * If the agents mutationMagnitude exceeds 0 then mutatingColor is returned,
     * else seedColor is returned.
     */
    @Override
    public Color getColor() {
        if (getMutationChance() > 0 && getColorModel().equals(ColorModel.ATTRIBUTES)) {
            return getMutatingColor();
        }
        else {
            return getSeedColor();
        }
    }
    @Override
    public String toString() {
        return "null";
    }
    @Override
    public Attributes copy() {
        return new MutatingAttributes(
                getSpawningWeight(),
                getName(),
                getID(),
                getSeedColor(),
                getColorModel(),
                getRandomColorModelMagnitude(),
                getMutationChance(),
                getRange(),
                getSize(),
                getCreationSize());
    }

}